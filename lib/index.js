// Generated by CoffeeScript 1.8.0
var filesize,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

filesize = require('./filesize');

Object.defineProperty(module.exports, 'mode', {
  get: function() {
    var mode;
    mode = function() {
      return mode.format.apply(mode, arguments);
    };
    mode.format = function(value) {
      if (typeof value === 'number') {
        return value.toString(8);
      } else {
        return value;
      }
    };
    mode.parse = function(value) {
      switch (typeof value) {
        case 'number':
          return value;
        case 'string':
          return parseInt(value, 8);
        default:
          throw Error("Invalid value " + (JSON.stringify(value)));
      }
    };
    mode.compare = function() {
      var i, ref, value, values, _i, _ref;
      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      ref = mode.parse(values[0]);
      for (i = _i = 1, _ref = values.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = mode.parse(values[i]);
        if (value !== ref) {
          return false;
        }
      }
      return true;
    };
    return mode;
  }
});

Object.defineProperty(module.exports, 'filesize', {
  get: function() {
    var build, directions, options, properties, proto, result, run, units;
    options = {
      action: 'format'
    };
    run = function() {
      var _ref, _ref1;
      if ((_ref = options.action) !== 'format' && _ref !== 'parse' && _ref !== 'compare') {
        throw Error;
      }
      return (_ref1 = filesize[options.action]).call.apply(_ref1, [null].concat(__slice.call(arguments), [options]));
    };
    build = function() {
      var builder;
      builder = function() {
        return run.apply(builder, arguments);
      };
      builder.__proto__ = proto;
      return builder;
    };
    result = function() {
      return result.format.apply(result, arguments);
    };
    properties = {
      format: {
        get: function() {
          options.action = 'format';
          return build();
        }
      },
      parse: {
        get: function() {
          options.action = 'parse';
          return build();
        }
      },
      compare: {
        get: function() {
          options.action = 'compare';
          return build();
        }
      },
      bit: {
        get: function() {
          options.bit = true;
          return build();
        }
      }
    };
    directions = ['from', 'to'];
    directions.forEach(function(direction) {
      return properties[direction] = {
        get: function() {
          if (options.direction) {
            throw Error("Invalid usage of " + direction);
          }
          options.direction = "" + direction;
          return build();
        }
      };
    });
    units = [['KB', 'kilobytes'], ['MB', 'megabytes'], ['GB', 'gigabytes'], ['TB', 'terabytes'], ['PB', 'petabytes'], ['EB', 'exabytes'], ['ZB', 'zettabytes'], ['YB', 'yottabytes'], ['Kb', 'kilobits'], ['Mb', 'megabits'], ['Gb', 'gigabits'], ['Tb', 'terabits'], ['Pb', 'petabits'], ['Eb', 'exabits'], ['Zb', 'zettabits'], ['Yb', 'yottabits']];
    units.forEach(function(unit) {
      properties[unit[0]] = {
        get: function() {
          var _ref;
          if (_ref = options.direction, __indexOf.call(directions, _ref) < 0) {
            throw Error('Use from or to before unit');
          }
          if (options[options.direction]) {
            throw Error("Unit already defined");
          }
          options[options.direction] = unit[0];
          options.direction = null;
          return build();
        }
      };
      return properties[unit[1]] = properties[unit[0]];
    });
    proto = Object.defineProperties(result, properties);
    return result;
  }
});
